# 007.64-コンピュータプログラミング

## 小分類

- 007.642-画像描画：コンピュータグラフィックス，アニメーション
- 007.645-マークアップ言語．ウェブサービス記述言語［WSDL］

## 分野の歴史

<!-- 
アウトライン
- 1. 前史：自動計算・アルゴリズムから「プログラム」へ（〜1940年代）
  - 数学的手続き（algorithm）の伝統と、計算を手続きとして書き下す発想
  - パンチカードと事務処理（統計・会計）における手順の機械化
  - チャールズ・バベッジ／エイダ・ラブレスに象徴される「手順の記述」と「機械の実行」の分離
  - 戦時研究・暗号解読・弾道計算が、計算の自動化を加速させた背景
- 2. 電子計算機とプログラム内蔵方式：機械語からアセンブリへ（1940〜50年代）
  - 配線・パッチパネルによる“手順そのものの変更”から、記憶装置上の命令列へ
  - 命令セット・番地指定・分岐によって「制御の流れ」を作るという基本形
  - アセンブラ／マクロによる記述性の向上と、ハードウェア差異が生む移植性問題
  - 入出力・バッチ処理・ジョブ制御と、プログラミング作業の実務化
- 3. 高級言語とコンパイラ：人間の記述と機械実行をつなぐ（1950〜60年代）
  - FORTRAN（数値計算）・COBOL（事務）・LISP（記号処理）など目的別言語の成立
  - コンパイラ最適化が「高級に書いても速い」を実現し、抽象化が現場へ浸透
  - ALGOL系に見られるブロック構造・スコープ・再帰など、言語設計の基礎概念
  - 標準化（規格）と移植性：同じソースを複数機で動かすという要請の高まり
- 4. 「ソフトウェア危機」と構造化：大規模化への反省から技法へ（1960〜70年代）
  - 規模拡大による品質・納期・保守の破綻（ソフトウェア危機）の問題意識
  - 構造化プログラミング（順次・選択・反復）と、goto依存からの脱却
  - モジュール化・抽象データ型・情報隠蔽：変更に強い設計へ
  - テスト、レビュー、ドキュメント化など、プログラミングを「工程」として扱う発想
- 5. CとUNIX、ライブラリ文化：実装と移植の両立（1970〜80年代）
  - システムを言語で書く：CとUNIXが示した「移植できる低水準」の成功
  - ツールチェーン（コンパイラ、リンカ、デバッガ）と開発作業の分業化
  - 標準ライブラリ／APIの拡充が、同じ部品を再利用する前提を作ったこと
  - 版管理の萌芽と、ソースコードを共同で扱う習慣（のちのVCSへ）
- 6. オブジェクト指向とGUI時代：ソフトウェアの“部品化”が進む（1980〜90年代）
  - Smalltalkに代表されるオブジェクト指向の概念（メッセージ、カプセル化、継承）
  - C++やJavaによる普及：大規模開発における再利用と拡張の枠組み
  - IDE・デバッガ・ビルド環境の高度化と、開発体験（DX）の変化
  - 設計パターンやコンポーネント指向が、コード共有の方法論を与えたこと
- 7. インターネットとWebプログラミング：公開環境で動くソフトへ（1990〜2000年代）
  - クライアント／サーバとスクリプト言語、動的生成（CGI等）の広がり
  - JavaScriptとブラウザ実行、HTML/XMLなどマークアップの役割
  - SOAP/WSDLなどのサービス記述と言語・ツールの連携、そしてREST的発想への移行
  - オープンソースの拡大が、学習・共有・再利用の速度を押し上げた点
- 8. 並行・分散・開発プロセス：動く場所が広がり作り方も変わる（2000〜2010年代）
  - マルチコア化と並行プログラミング（スレッド、ロック、メッセージ、非同期）の難しさ
  - 分散システムとスケール：RPC、キュー、マイクロサービスなどの設計上の要点
  - Git等のVCS、CI、テスト自動化、アジャイル、DevOpsが“日常の作法”になる過程
  - セキュリティ（脆弱性・依存関係）と品質保証が、プログラミングと不可分になったこと
- 9. 現代：クラウドネイティブとAI支援、そしてプログラミングの再定義（2010年代〜）
  - コンテナ、IaC、サーバレス等により「コード＝運用手順」まで含むようになった変化
  - 型システム、静的解析、形式手法の実務化が、規模と安全性の両立を支える点
  - GPU/シェーダやゲーム・可視化など、画像描画領域を含む実装技術の拡張
  - 生成AI・支援ツールによる記述・探索・レビューの変化と、責任分界（著作権・安全性）
  - 日本における教育・産業・コミュニティ（資格、学校教育、企業文化）と今後の課題
-->

コンピュータプログラミングとは、機械に仕事をさせるための手順を、誤りなく再現できる形で記述し、実行・検証し、必要なら書き換えて共有し続ける営みである。ここには言語や処理系（コンパイラ／インタプリタ）だけでなく、テスト、版管理、配布、運用までが含まれる。道具は入れ替わっても、「意図を正しく伝えたい」「壊さずに変えたい」「他者と協力して作りたい」という要求は一貫している。
プログラミングが「歴史」になるのは、手順がソースコードとして残り、読まれ、改良され、再利用されるからだ。コンパイル、リンク、実行という流れは、ただ動かすための儀式ではなく、手順を別の形へ翻訳し、部品を結び付け、環境へ載せる工程でもある。プログラマは、コードだけでなく、コードが動くまでの道筋を設計し、誤りが混ざる余地を減らしてきた。
プログラミングは、画像描画（コンピュータグラフィックス、アニメーション）や、マークアップ言語・ウェブサービス記述言語（WSDL）のような周辺領域とも強く結びつきながら発展してきた。しかしプログラミングの歴史は、それら個別領域の寄せ集めではない。本節では、抽象化と標準化、そして共同作業の作法がどう積み重なってきたかを軸に、分野全体が一つの物語としてつながるように辿る。以後の章では、チャールズ・バベッジからティム・バーナーズ＝リー、リーナス・トーバルズに至るまで、重要な固有名詞を手がかりに、技術と文化がどう連鎖したかを具体的に描く。
標準化は自由を制限するが、学習・移植・共同開発を支える。プログラミングの歴史は、その境界を調整し続けてきた。

### 1. 前史：自動計算・アルゴリズムから「プログラム」へ（〜1940年代）
プログラミングの遠い祖先は、計算や作業を「手順」として外部化してきた人間の文化にある。ユークリッド（紀元前3世紀頃）の互除法のように、入力から出力までの道筋を規則として書けるなら、誰が実行しても同じ結果が得られる。手順が書かれ、読まれ、比較されることで、「良い手順／悪い手順」という評価の文化が生まれる。これは後に、コーディング規約や設計原則へつながる発想でもある。
近代の事務処理では、パンチカードが象徴するように、データと手順を媒体に載せて機械に通すという方法が広がった。そしてチャールズ・バベッジの解析機関構想（1837年）と、エイダ・ラブレスが1843年に残した注釈は、「機械の構造」と「手順の記述」を分けて考える視点を与えた。さらにアラン・チューリングの計算可能性の議論（1936年）は、手続きの範囲を理論として定めた。第二次世界大戦（1939〜1945年）の暗号解読や弾道計算の現場は、理論と実務を結びつけ、手順を機械に委ねる必然性を増幅した。
この時代の「媒体に刻む」という感覚は、ジャカード織機の紋紙のように、パターンを繰り返し再生する仕組みにも見える。差分機関や解析機関の構想が魅力的だったのは、手順が一度書ければ、何度でも同じ品質で実行できるという約束があったからだ。プログラミングは最初から、再現性と再利用性を求める欲望とともに始まっている。

### 2. 電子計算機とプログラム内蔵方式：機械語からアセンブリへ（1940〜50年代）
電子計算機の初期には、配線やパッチパネルの変更がそのまま「手順の変更」だった。ところが、命令列をデータと同じように記憶装置に置き、読み出して実行するプログラム内蔵方式が普及すると、手順は書き換え可能な情報になる。ENIAC（1946年）からEDVACへ、そしてジョン・フォン・ノイマンの報告書（1945年）に代表されるアーキテクチャの整理は、後の時代まで続く基本形を与えた。
一方で、機械語は人間にとって過酷である。番地やレジスタ、入出力装置の癖がそのままコードに現れ、誤りは些細な桁違いで致命傷になる。ここでアセンブリ言語とアセンブラが生まれ、記述は記号化され、マクロで定型が再利用されるようになった。モーリス・ウィルクスがEDSAC（1949年）で進めたサブルーチン・ライブラリの発想は、部品化の重要性を示す。こうしてプログラミングは「書く」だけでなく、誤りを追跡するデバッグ、手順全体を整えるジョブ制御へと、仕事の範囲を広げていく。
また、この時代は「プログラマ」という職能が輪郭を持つ時代でもある。ENIACを作ったジョン・モークリーやJ・プレスパー・エッカートのようなハードウェア側の人物が語られがちだが、実際に動く手順を作り、誤りを潰し、運用に耐える形へ仕上げる仕事が不可欠だった。グレース・ホッパーが「バグ（bug）」の逸話とともに語られるのも、誤りを体系的に扱う文化が、すでに現場の中心課題だったことを示している。
ここで重要なのは、プログラムが「一度きりの計算」から「繰り返し使う仕組み」へ変わるにつれて、手順の品質が社会的な価値になることだ。UNIVAC I（1951年）のような商用機の登場は、計算機を研究施設から事務の現場へ押し出し、プログラムは“運用される資産”になる。運用される以上、手順には説明可能性と再現性が必要であり、その要求が後の高級言語や標準化を呼び込んでいく。

### 3. 高級言語とコンパイラ：人間の記述と機械実行をつなぐ（1950〜60年代）
高級言語は、意図をより短く、より明確に書くための道具として登場した。ジョン・バッカスのFORTRAN（1957年）は数値計算の現場で力を発揮し、グレース・ホッパーの流れを汲むCOBOL（1959年）は事務処理の標準化を推し進めた。ジョン・マッカーシーのLISP（1958年）は記号処理の世界を切り開き、人工知能研究の言語としても長く影響を残す。言語が違えば「よく書く形」も違い、プログラミングは目的に合わせて道具を選ぶ文化を持ち始めた。
同時に、コンパイラは単なる翻訳機ではなく、最適化で実行効率を支え、型検査で誤りを早期に発見する役割を担うようになる。ALGOL 60（1960年）に代表されるブロック構造やスコープは、プログラムを意味のある塊として整理する枠組みを与えた。ジョン・バッカスとピーター・ナウアのバッカス＝ナウア記法（BNF、1959〜1960年頃）は、言語仕様を厳密に書く方法として定着し、標準化と移植性の議論を支える。プログラミングは、個人芸から、学べる技術体系へと変わっていった。
この頃から、言語処理系の差は「実行速度」だけでなく「開発速度」にも影響する。対話的に試せるREPLは学習と実験を加速し、バッチ中心の世界に「試して確かめる」リズムを持ち込んだ。後にハロルド・アーベルソンとジェラルド・ジェイ・サスマンの『計算機プログラムの構造と解釈』（1985年）が示したように、言語を通して「計算の考え方」を教える試みは、文法暗記とは別の学習観を広めていく。
また、言語が普及するほど「同じ言語なのに動かない」問題が現れる。そこでANSIやISOのような標準化が進み、仕様を文章として固定する努力が積み重なった。移植性は単に便利なだけではなく、教育と採用と長期保守を支える条件になる。どの言語を選ぶかは、文法の好み以上に、周辺のエコシステム（処理系、ライブラリ、教材、コミュニティ）を含む判断へ変わっていった。
教育と普及という観点では、ジョン・ケメニーとトーマス・カーツが提案したBASIC（1964年）の存在も大きい。コンピュータを一部の研究者や技術者だけでなく、学生や一般の利用者が触れるものにするために、簡潔な文法と対話的な環境が用意された。もちろん、後にBASICが乱用され、保守性や構造の問題が指摘されるようになるが、その議論自体が「読みやすさ」「構造」「教育」という価値軸を社会へ持ち込んだ。プログラミングは、専門技術であると同時に、学びの文化としても拡張されていく。

### 4. 「ソフトウェア危機」と構造化：大規模化への反省から技法へ（1960〜70年代）
計算機が社会の重要な仕事を担うにつれ、プログラムは巨大化し、変更と保守が日常になる。すると「動く」だけでは足りず、「直せる」「壊さずに変えられる」ことが価値になる。1968年10月のNATOソフトウェア工学会議で象徴されるソフトウェア危機の議論は、プログラミングを工程として捉え直す契機になった。
ここで広がったのが構造化プログラミングである。エドガー・W・ダイクストラの論文「goto文は有害である（Go To Statement Considered Harmful、1968年）」は、制御の流れを読みやすい構造に制限する発想を強く印象づけた。モジュール化、情報隠蔽、抽象データ型といった原則は、仕様と実装の境界を整え、他者と分担して作るための土台になる。フレデリック・P・ブルックスの『人月の神話』（1975年）が示したように、人数や工程だけでは解決できない難しさもあるが、テスト、レビュー、ドキュメント化といった実務が「作る技術」の中核へ組み込まれていった。
この時代の議論は、単なる作法ではなく「正しさ」をどう扱うかにも及ぶ。C・A・R・ホーアのホーア論理（1969年）は、プログラムの性質を論理で記述し、証明へつなげる発想を与えた。また、ニクラウス・ヴィルトの『アルゴリズム＋データ構造＝プログラム』（1976年）や、ドナルド・E・クヌースの『The Art of Computer Programming』（第1巻1968年）は、アルゴリズムとデータ構造をプログラミングの中心に据え、読み書きできる知識体系として提示した。実務の現場が求めたのは、万能の理論ではなく、複雑さを抑えて「直せる」状態を保つための道具立てだった。

### 5. CとUNIX、ライブラリ文化：実装と移植の両立（1970〜80年代）
多様な計算機の上で、同じ発想をどう動かすか。その問いに現実的な答えを与えたのが、ベル研究所でケン・トンプソンとデニス・リッチーが育てたUNIX（1969年）と、デニス・リッチーのC言語（1972〜1973年）である。システムそのものを高級言語で書くという選択は、移植性と実装力の両立を可能にした。ブライアン・W・カーニハンとデニス・M・リッチーの『プログラミング言語C』（1978年）は、言語と実務を結びつけた代表的な書物として読まれ続けている。
同時に、標準ライブラリやAPIが整うほど、プログラミングは部品の組み立てへ近づく。文字列処理、入出力、ネットワーク、描画といった共通機能が共有されれば、問題の本質へ集中できる。画像描画では、座標変換、クリッピング、ラスタライズといった段階が意識され、後のGPUやシェーダへつながる「パイプライン」の感覚が育った。さらに、ソースコードを履歴として扱う版管理（RCSやCVSなど）の文化は、プログラムを“生き物”として継続的に育てる視点を一般化していく。
自由ソフトウェアの運動もまた、共有の力学を変えた。リチャード・ストールマンがGNUプロジェクト（1983年）とGNU GPL（1989年）を掲げ、GCC（1987年）やGNU Emacs（1985年）のような道具が広がると、ソースコードは「読める・直せる・配れる」資産として価値を持つ。POSIX（1988年）のような規格は、環境差を吸収する約束として働き、移植性の土台を固めた。プログラミングは、技術と同時にライセンスと共同体によっても進むのだ、という認識が強まっていく。
UNIXの文化が残したもう一つの遺産は、ツールを小さく作り、組み合わせて大きな仕事をする発想である。スティーブン・ボーンのBourne shell（sh）や、sed、awkといった道具、そしてパイプによる連結は、プログラミングを「巨大なアプリケーション」だけでなく「自動化された手順の集合」として捉え直した。ビルドではmake（スチュアート・フェルドマン）に代表される自動化が普及し、「どう作るか」をコードとして残す習慣が定着していく。後のCIやIaCは、その延長線上にある。

### 6. オブジェクト指向とGUI時代：ソフトウェアの“部品化”が進む（1980〜90年代）
PCとGUIの普及は、ソフトウェアが相手にする利用者を拡大し、イベント駆動や状態管理を日常にした。ゼロックスPARCのアラン・ケイらが牽引したSmalltalk（1972年）は、オブジェクトとメッセージという考え方を提示し、以後の言語設計に強い影響を与える。ビャーネ・ストロヴストルップのC++（1985年）は既存の実装資産と折り合いを付けながらオブジェクト指向を広め、ジェームズ・ゴスリングのJava（1995年）は仮想マシンと標準ライブラリを武器に企業システムへ浸透した。
GUIが広がると、プログラムは「上から下へ流れる手順」よりも、「イベントに反応し続ける状態機械」に近づく。AppleのMacintosh（1984年）やMicrosoft Windows（1985年）の普及は、画面部品や入力の取り扱いを共通化し、フレームワークの上でアプリケーションを組み立てる発想を一般化した。ここでは、部品の境界をどう切るか、責務をどう割るかがそのまま保守性を左右し、オブジェクト指向は“画面の複雑さ”と戦うための言語になった。
大規模化の現場では、経験が「型」として共有される。エーリッヒ・ガンマ、リチャード・ヘルム、ラルフ・ジョンソン、ジョン・ヴリシデスの『オブジェクト指向における再利用のためのデザインパターン』（1994年）は、再利用可能な設計の語彙を与えた。さらにマーティン・ファウラーの『リファクタリング』（1999年）が示したように、動くプログラムを壊さずに改善する技法は、保守を前提とする時代の必須技能になる。統合開発環境（IDE）も、探索・補完・デバッグを支え、プログラミングの作業風景を変えていった。
同時期には、部品を“配布できる単位”として扱う試みも進む。MicrosoftのCOMや、分散オブジェクトを目指したCORBA、JavaのJavaBeansなどは、異なる言語やプロセスの境界を越えて再利用するための約束だった。後の時代に成功・失敗の評価は分かれても、「境界を仕様として固定し、実装を入れ替え可能にする」発想は、Web APIやマイクロサービスにも受け継がれていく。
画像描画の観点でも、GUI時代は大きい。アイバン・サザーランドの「Sketchpad」（1963年）は、画面上の図形を対話的に操作するという発想を早い段階で示し、後のCADやGUIの基礎になった。OpenGL（1992年）やDirectX（1995年）のようなAPIは、ハードウェアの差を越えて描画を行う約束を整え、ゲームや可視化の開発を加速する。ここでも、標準化された境界（API）が、学習と移植と共同開発を支える役割を果たした。

### 7. インターネットとWebプログラミング：公開環境で動くソフトへ（1990〜2000年代）
インターネットの普及は、プログラムを「閉じた環境」から「公開された環境」へ押し出した。ティム・バーナーズ＝リーが提案したWorld Wide Web（1989年）とHTML（1991年）は、ブラウザという共通実行環境を生み、配布と更新の形を変えた。ブレンダン・アイクが設計したJavaScript（1995年）は、ブラウザ内で動くプログラムを一般化し、ユーザー体験をコードで作る道を開いた。XML（1998年）は構造化データの交換を支え、文書や設定、プロトコルに広く使われた。
サーバ側でも、Webはプログラミングの入口を広げた。Apache HTTP Server（1995年）の普及とともに、CGIやPHP（1995年）、Perlなどで動的ページを作る手法が広がり、後にJavaのServlet/JSP、PythonやRubyのフレームワークが追随する。公開環境で動く以上、入力は信用できず、ログを残し、障害に備え、段階的に更新する必要がある。ここでセキュリティと運用は、もはや「後から足すもの」ではなく、最初から設計に含まれる条件になった。
同時に、Webは「境界」を意識させる。ブラウザとサーバ、組織と組織、言語とランタイム。その境界で合意を作るために、WSDL（2001年）のようなサービス記述、スキーマ、ドキュメント生成が重視された。やがてロイ・フィールディングが博士論文（2000年）で整理したRESTの考え方が広がると、Webは軽量な連携の基盤として再解釈される。安全性（入力検証、認証・認可、暗号化）が設計の中心へ移ったのも、公開環境で動く宿命ゆえである。
Webの発展は、言語の勢力図も変えた。ラスマス・ラードフのPHP（1995年）は「まず動かす」文化とともに普及し、グイド・ヴァン・ロッサムのPython（1991年）は読みやすさと豊富なライブラリで学習と実務の橋渡しをした。まつもとゆきひろ（Matz）のRuby（1995年）と、デビッド・ハイネマイヤー・ハンソンのRuby on Rails（2004年）は、Webアプリケーション開発の生産性を大きく引き上げた。データ交換では、ダグラス・クロックフォードが普及を後押ししたJSON（2001年）が、軽量な共通形式として広がり、マークアップとデータ表現の役割分担を変えていく。
標準の担い手も多層化した。W3CはHTMLやCSSの仕様を整え、IETFはHTTPやTLSのようなプロトコルをRFCとして育てる。プロトコルが文章で公開されることで、実装は特定企業の製品に依存せず、相互運用性という価値が守られる。Webプログラミングは、コードを書く力と同じくらい、仕様を読み、互換性を考え、境界条件を詰める力を要求する分野になった。
ブラウザ側では、いわゆるAjax（2005年）や、Google Maps（2005年）に象徴されるリッチなWebアプリケーションが登場し、画面は“文書”から“アプリ”へ近づいた。するとフロントエンドの構造化、ビルド、テスト、性能最適化といった課題が一気に増える。プログラミングは、単に機能を追加することではなく、利用者体験と性能、互換性を同時に扱う設計問題になっていく。

### 8. 並行・分散・開発プロセス：動く場所が広がり作り方も変わる（2000〜2010年代）
計算機は速くなるだけでなく、マルチコア化し、分散して動くようになった。スレッドやロックは強力だが、競合やデッドロックのような見えにくい失敗を呼び込む。そこで非同期I/O、メッセージパッシング、不変データといった考え方が再評価され、言語やライブラリは並行性を扱いやすくする方向へ伸びていく。分散システムでは、通信の遅延や部分的な失敗が常態となり、冪等性、再試行、タイムアウト、監視が「プログラミングの語彙」になる。
並行性の扱い方は、言語設計にも反映される。ジョー・アームストロングのErlang（1986年）が示した「プロセスとメッセージ」の発想や、ロブ・パイクらのGo（2009年）が掲げた簡潔な並行機構は、現場の痛みへの回答として語られた。どの流派であれ、狙いは同じで、複雑な同時実行を人が理解できる形へ落とし込むことにある。
作り方も変わった。2001年の「アジャイルソフトウェア開発宣言」や、ケント・ベックのエクストリーム・プログラミング（XP）が象徴するように、変化を前提に短いサイクルで価値を積む方法が普及する。リーナス・トーバルズが作ったGit（2005年）は分散版管理を日常にし、CI（継続的インテグレーション）や自動テスト、コードレビューが当たり前になる。依存関係が増えるほど、更新の波及や脆弱性の連鎖も増えるため、パッケージ管理と品質保証は切り離せなくなっていった。
運用の世界でも、学びが共有される。ジェズ・ハンブルとデイビッド・ファーリーの『継続的デリバリー』（2010年）は、リリースを一回限りのイベントから、日常の工程へ変える道筋を整理した。オープンソースの共同開発の姿を論じたエリック・S・レイモンドの『伽藍とバザール』（1997年）は、分散した協働が品質と速度を両立し得ることを示した。こうした知見が、DevOpsやSREへつながり、プログラミングの成果物は「運用されること」を前提に設計されるようになる。
分散の現実を押し上げたのは、巨大サービスの実践でもある。ジェフ・ディーンとサンジェイ・ゲマワットのMapReduce（2004年）や、Google File System（2003年）に代表される設計は、「壊れる前提で動かす」発想を一般化した。Apache Hadoop（2006年）のような実装が広がると、分散処理は研究テーマから実務の選択肢へ降りてくる。こうした土台の上で、マイクロサービスやイベント駆動、メッセージングといった設計が語られるようになり、プログラミングは単体の正しさだけでなく、全体の振る舞いを観測し続ける設計へ重心を移していった。

### 9. 現代：クラウドネイティブとAI支援、そしてプログラミングの再定義（2010年代〜）
クラウドは、計算資源を「所有」から「利用」へ変えた。AWS（2006年）のようなプラットフォーム、Docker（2013年）に代表されるコンテナ、Kubernetes（2014年）、Infrastructure as Codeといった考え方は、実行環境そのものをコードで扱う流れを加速し、運用と開発を一体化させる。型システム、静的解析、メモリ安全性への関心が高まったのも、巨大な依存関係と長期運用の中で「壊れにくさ」が重要になったからである。Graydon Hoareが起点となったRust（2015年のRust 1.0）が注目される背景にも、性能と安全性の両立という現場の要請がある。
さらに、生成AIが開発の風景を変えつつある。GitHub Copilot（2021年）やOpenAIのChatGPT（2022年）のような支援は、探索、補完、要約、レビュー補助を高速化する一方で、誤りや偏り、著作権、機密情報の扱いといった新しい責任を生む。日本では情報処理技術者試験（IPA）や学校教育の必修化、そしてコミュニティ活動を通じて裾野が広がってきたが、これから重要になるのは、特定の言語の流行よりも、抽象化・分割・検証・共有という基礎を、道具が変わっても使い続ける力だろう。プログラミングは、技術の歴史であると同時に、社会が手順を共有し、信頼の上でソフトウェアを動かし続けるための歴史でもある。
同時に、ソフトウェアは「依存するもの」の集合でもあるため、サプライチェーンの健全性が課題になる。脆弱性対応、署名、SBOM（Software Bill of Materials）のような考え方は、単なるセキュリティ部門の仕事ではなく、開発者の日常へ入り込んできた。生成AIがコードを生みやすくするほど、何を採用し、どこで責任を引き受け、どう検証するかが問われる。プログラミングは、書く速さだけでなく、確かめて続ける速さを競う時代に入っている。
日本でも、この変化は学び方と働き方を変えた。情報処理技術者試験（IPA）は共通の語彙を作り、AtCoderのような競技プログラミングはアルゴリズムの基礎体力を鍛える場になった。一方で、RubyKaigiやPyCon JP、技術書典のようなイベントは、実務の知見を共有し、若い開発者を育てるコミュニティの役割を果たしてきた。言語や道具が変わり続けるからこそ、共同体が知識を翻訳し直し、学びの入口を増やすことが重要になる。
検証の技法もまた、プログラミングを支える基盤として成熟している。ユニットテストやCIが当たり前になった後も、境界条件を網羅するのは難しい。そこでジョン・ヒューズらが提案したQuickCheck（2000年）に代表されるプロパティベーステストや、ファジング（fuzzing）のように入力を自動生成して破綻を探す手法が広がり、脆弱性や不具合を「運用前に見つける」ための道具が増えた。生成AIがコード生成を加速するほど、人間は“書く”より“確かめる”側へ重心を移し、検証の設計そのものがプログラミングの中核になっていく。
未来を占う鍵は、結局のところ「境界の設計」にある。画像描画なら、GPUとアプリケーションの境界をAPIとしてどう切るか。Web連携なら、WSDLのように契約を明示するのか、RESTのように資源として設計するのか。AI支援なら、生成物をどの範囲で信頼し、どこからをテストやレビューで担保するのか。境界は責任分担であり、仕様と検証と運用の積み重ねが信頼を作る。生成AI時代も、この原則は変わらない。プログラミングはその積み重ねを、より多くの人が参加できる形へ更新し続ける歴史なのである。
